---
title: "XML Annotation Preprocessing"
format: html
editor: visual
---

```{r, echo=FALSE, message=FALSE}
rm(list = ls())

library(xml2)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(readxl)
```

In this code, we aim to process an XML file to extract meaningful annotations and structure them into a well-organized table. XML files often contain rich metadata, but extracting relevant information requires parsing and transformation into a more readable format, such as a CSV or TSV table.

The resulting annotation table will provide a structured view of the extracted data, making it easier to analyze and use in the downstream analysis.

## Set up

We specify the XML file and namespace for the file.

```{r}
xml_file <- "../../data/raw/UP000005640_9606.xml"  
ns <- c(uniprot = "https://uniprot.org/uniprot")
```

## Process XML file

We will create a function to process features from an entry in the XML file.

```{r}
process_features <- function(entry, ns){
  
  # Extract accession for the current entry.
  accession <- xml_text(xml_find_first(entry, ".//uniprot:accession", ns))
  
  # Extract sequence length from the <sequence> tag.
  sequence <- xml_find_all(entry, ".//uniprot:sequence", ns)
  sequence_length <- as.numeric(xml_attr(sequence[[length(sequence)]], "length"))
  
  # Save the length with accession.
  length <- data.frame(
    accession = accession,
    length = sequence_length
    )
  
  # Extract all feature elements for the current entry.
  features <- xml_find_all(entry, ".//uniprot:feature", ns)

  # Initialize a list to store feature data.
  feature_list <- list()
  
  # Loop through each feature and extract information.
  for (feature in features){
    
    # Get feature type, description and location.
    feature_type <- xml_attr(feature, "type")
    description <- xml_attr(feature, "description")
    location <- xml_find_first(feature, ".//uniprot:location", ns)
    
    # Get position (for the annotation of single amino acids).
    pos <- xml_find_first(location, ".//uniprot:position", ns)
    
    # Define the span of the annotated region.
    if (!is.na(pos)){
      start_pos <- as.numeric(xml_attr(pos, "position"))
      end_pos <- as.numeric(xml_attr(pos, "position"))
    } else {
      start_pos <- xml_find_first(location, ".//uniprot:begin", ns)
      start_pos <- as.numeric(xml_attr(start_pos, "position"))
      end_pos <- xml_find_first(location, ".//uniprot:end", ns)
      end_pos <- as.numeric(xml_attr(end_pos, "position"))
    }
    
    # Store the feature information.
    feature_list <- append(feature_list, list(data.frame(
      accession = accession,
      feature_type = feature_type,
      description = description,
      start_position = start_pos,
      end_position = end_pos,
      stringsAsFactors = FALSE
    )))
  }
  
  return(list(feature_list, length))
}
```

We read the XML file.

```{r}
xml_data <- read_xml(xml_file)
  
# Find all entry elements in the XML file
entries <- xml_find_all(xml_data, ".//uniprot:entry", ns)
  
# Initialize a list to store the results
features <- list()
lengths <- list()

entry_num = 0

for (entry in entries){
  entry_num = entry_num + 1
  results <- process_features(entry, ns)
  features <- append(features, results[[1]])
  lengths <- rbind(lengths, results[[2]])
  
  if (entry_num %% 1000 == 0){
    print(paste(entry_num, "entries completed"))
  }
}

# Combine the feature data from all chunks into a single data.table
feature_data <- tibble(do.call(rbind, features))
length_data <- tibble(lengths)
```

## Filter TrEMBL sequences

We are only interested in the SWISS-PROT entries as these are manually annotated unlike TrEMBL sequences. The accessions belonging to each database is stored in txt files loaded below.

```{r}
accessions_sp <- read.table(file = "../../data/20000_large/additional/UP000005640_9606_sp_acc.txt") |>
  rename(accession = V1)

accessions_tr <- read.table(file = "../../data/20000_large/additional/UP000005640_9606_tr_acc.txt") |>
  rename(accession = V1)
```

We will filter out TrEMBL sequences for both the feature and length data generated above.

```{r}
feature_data_sp <- feature_data |>
  filter(accession %in% accessions_sp$accession)

length_data_sp <- length_data |>
  filter(accession %in% accessions_sp$accession)
```

We do a sanity check to see if all SWISS-PROT accessions appear in the feature table.

```{r}
print(paste("Accessions from SWISS-PROT:", 
            length(unique(feature_data_sp$accession))))
print(paste("Unique accessions in feature table found in accession list:", 
            sum(unique(feature_data_sp$accession) %in% accessions_sp$accession)))
```

We save the results.

```{r}
saveRDS(feature_data_sp, file = "../../data/20000_large/annotations/features_sp.rds")
saveRDS(length_data_sp, file = "../../data/20000_large/additional/seq_lengths_sp.rds")
```

## Filter annotation types

We look at the frequency for the different annotation types.

```{r}
feature_data_sp |>
  mutate(feature_type = str_to_title(feature_type)) |>
  count(feature_type) |>
  arrange(desc(n)) |>  
  ggplot(aes(x = reorder(feature_type, -n),
             y = n)) +
  geom_bar(stat = "identity", 
           fill = "#1f618d",
           alpha = 0.8) +
  labs(title = "Frequency of Annotation Types",
       x = "Annotation Type",
       y = "Frequency") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

We are not interested in all annotation types from UniProt. We read in a file describing whether to keep a annotation or not.

```{r}
annotation_types <- read_excel(path = "../../other/annotation_type_list.xlsx", 
                               sheet = "R")
```

We join the tibbles by feature type.

```{r}
feature_data_sp <- left_join(feature_data_sp, annotation_types, by = "feature_type")
```

We filter the annotations based on the keep column.

```{r}
feature_data_sp_filtered <- feature_data_sp |>
  filter(keep == 1) |>
  select(!keep) |>
  relocate(category,
           .after = accession)
```

We look at the frequency for the different annotation types after filtering.

```{r}
feature_data_sp_filtered |>
  mutate(feature_type = str_to_title(feature_type)) |>
  count(feature_type) |>
  arrange(desc(n)) |>  
  ggplot(aes(x = reorder(feature_type, -n),
             y = n)) +
  geom_bar(stat = "identity", 
           fill = "#1f618d",
           alpha = 0.8) +
  labs(title = "Frequency of Annotation Types",
       x = "Annotation Type",
       y = "Frequency") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Filter annotations beyond position 1024

The ESM-2 model will only consider proteins of 1024 amino acids or less. Thus, we will consider the distribution of sequence lengths.

```{r}
ggplot(length_data_sp, 
       aes(x = length)) +
  geom_histogram(aes(y = ..density..), 
                 binwidth = 2, 
                 fill = "#1f618d",
                 color = "#1f618d",
                 alpha = 0.8) +
  labs(x = "Amino Acid Length",
       y = "Density") +
  theme_classic()
```

It is difficult to look at the plot above do to outliers. Therefore, we consider the quantiles.

```{r}
quantile(length_data_sp$length, probs = c(0.25, 0.5, 0.75, 0.90, 0.95))
```

Let's get the percentage of sequences longer than 1024.

```{r}
n <- sum(length_data_sp$length > 1024)

print(paste("Percentage of sequences larger than 1024:", round(n/length((length_data_sp$length))*100, digits = 2)))
```

For the long sequences, we chose to crop them and only consider the first 1024 positions. However, we wish to avoid cropping a sequence in the middle of an annotation. If found to be in the middle of an annotation for position 1024, the edge will be define as the position prior to the start of the annotated region or site.

```{r}
length_adjusted <- left_join(feature_data_sp_filtered,
                             length_data_sp,
                             by = "accession") |>
  filter(length > 1024, start_position < 1024, end_position > 1024) |>
  group_by(accession) |>
  mutate(length_adj = min(start_position) - 1) |>
  count(accession, length_adj) |>
  select(accession, length_adj)
```

We will join the adjusted length with the filtered annotations.

```{r}
feature_data_sp_filtered <- left_join(feature_data_sp_filtered,
                                      length_data_sp,
                                      by = "accession") |>
  left_join(length_adjusted,
            by = "accession") |>
  mutate(length_adj = case_when(is.na(length_adj) ~ length,
                                .default = length_adj),
         length_adj = case_when(length_adj > 1024 ~ 1024,
                                .default = length_adj))
```

One might be concerned that by adjusting the length in this way, we would end up removing almost everything when an annotation spans a large area in the beginning of the sequence but extents beyond position 1024. Thus, we look into the adjusted length of the cropped sequences.

```{r}
feature_data_sp_filtered |>
  mutate(width = end_position - start_position) |>
  filter(length > 1024) |>
  count(accession, length_adj) |>
  ggplot(aes(x = length_adj)) +
  geom_boxplot(fill = "#1f618d",
               alpha = 0.8) + 
  theme_classic()
```

It seems fair.

```{r}
feature_data_sp_filtered |>
  mutate(width = end_position - start_position) |>
  filter(length > 1024) |>
  count(accession, length_adj) |>
  select(length_adj) |>
  pull() |>
  quantile(probs = c(0.1, 0.25, 0.5, 0.75, 0.90, 0.95))
```

For the sequences longer than 1024 corresponding to 2286 sequences, 25% will have an adjusted length of 854 or longer. Before filtering away the annotations, which will not be considered, we will take a look at what is removed.

```{r}
feature_data_sp_filtered |>
  filter(!is.na(start_position)) |>
  mutate(keep = case_when(start_position <= length_adj ~ "Yes",
                          start_position > length_adj ~ "No")) |>
  mutate(feature_type = str_to_title(feature_type)) |>
  ggplot(aes(x = feature_type,
             fill = keep)) +
  geom_bar(position = "fill",
           alpha = 0.8) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Feature type",
       y = "Proportion",
       fill = "Keep") + 
  scale_fill_manual(values = c("#990000", "#1f618d"))
```

Finally, we remove the annotations that does not appear in the cropped sequence. Furthermore, we remove annotation without start and end positions.

```{r}
feature_data_sp_filtered <- feature_data_sp_filtered |>
  mutate(keep = case_when(start_position <= length_adj ~ "Yes",
                          start_position > length_adj ~ "No")) |>
  filter(keep == "Yes",
         !is.na(start_position),
         !is.na(end_position)) |>
  select(!keep)
```

We save the results.

```{r}
saveRDS(feature_data_sp_filtered, file = "../../data/20000_large/annotations/features_sp_filtered.rds")
```

To adjust the sequence length, we will save the length data in a CSV file.

```{r}
write.csv(length_adjusted, "../../data/20000_large/additional/seq_lengths_adj.csv", row.names = FALSE)
```

## Overview of annotations for smaller data set (100 sequence)

We will look at a subset of the data used for initial studies. First, let's load the accesion numbers.

```{r}
accessions_sp_100 <- read.table(file = "../../data/100_small/additional/UP000005640_9606_sp_100_acc.txt") |>
  rename(accession = V1)
```

We will filter out the sequences.

```{r}
feature_data_sp_100_filtered <- feature_data_sp_filtered |>
  filter(accession %in% accessions_sp_100$accession)
```

The annotations for the 100 sequences are saved.

```{r}
saveRDS(feature_data_sp_100_filtered, file = "../../data/100_small/annotations/features_sp_100_filtered.rds")
```

We take a look at which annotations are not included:

```{r}
unique(feature_data_sp_filtered$feature_type) %in% annotation_types$feature_type
```

All annotations after filtering are represented among the 100 sequences. We take a look at the length of the sequences.

```{r}
length_data_sp_100 <- length_data_sp |>
  filter(accession %in% accessions_sp_100$accession)
```

We count the number of sequence larger than 1024.

```{r}
n <- sum(length_data_sp_100$length > 1024)

print(paste("Sequences larger than 1024:", n))
```
